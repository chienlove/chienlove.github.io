name: Sign IPA with optional identifier

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag ch·ª©a IPA"
        required: true
      identifier:
        description: "(Tu·ª≥ ch·ªçn) Bundle Identifier m·ªõi"
        required: false

jobs:
  sign:
    runs-on: macos-latest
    permissions:
      contents: write
      packages: read

    env:
      GH_TOKEN: ${{ github.token }}
      REPO: ${{ github.repository }}
      SUPABASE_URL: https://zkbzykamrzvvrhodiypk.supabase.co
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Fetch cert info from Supabase
        run: |
          response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
            -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
            -H "Accept: application/json" \
            "${SUPABASE_URL}/rest/v1/certificates?select=*")

          http_status=$(echo "$response" | grep HTTP_STATUS: | cut -d':' -f2)
          json_data=$(echo "$response" | sed '/HTTP_STATUS/d')

          if [ "$http_status" -ne 200 ]; then
            echo "::error::Supabase API error $http_status"
            exit 1
          fi

          echo "$json_data" | jq '.[0]' > cert.json

          export CERT_P12_URL=$(jq -r '.p12_url' cert.json)
          export CERT_PROVISION_URL=$(jq -r '.provision_url' cert.json)
          export CERT_PASSWORD=$(jq -r '.password' cert.json)

          echo "CERT_P12_URL=$CERT_P12_URL" >> $GITHUB_ENV
          echo "CERT_PROVISION_URL=$CERT_PROVISION_URL" >> $GITHUB_ENV
          echo "CERT_PASSWORD=$CERT_PASSWORD" >> $GITHUB_ENV

      - name: Download certificates
        run: |
          curl -L "$CERT_P12_URL" -o cert.p12
          curl -L "$CERT_PROVISION_URL" -o embedded.mobileprovision

      - name: Set variables
        run: |
          echo "TAG=${{ github.event.inputs.tag }}" >> $GITHUB_ENV
          if [ -n "${{ github.event.inputs.identifier }}" ]; then
            echo "NEW_ID=${{ github.event.inputs.identifier }}" >> $GITHUB_ENV
          else
            echo "NEW_ID=" >> $GITHUB_ENV
          fi

      - name: Verify release exists
        run: |
          gh release view "$TAG" --repo "$REPO"

      - name: Download IPA from release
        run: |
          gh release download "$TAG" \
            --repo "$REPO" \
            --pattern "*.ipa" \
            --clobber
          IPA_NAME=$(ls *.ipa)
          echo "IPA_NAME=$IPA_NAME" >> $GITHUB_ENV

      - name: Unpack IPA and (optionally) change Bundle ID
        run: |
          unzip -q "$IPA_NAME" -d unpacked
          APP_PATH=$(find unpacked/Payload -name "*.app" -print -quit)

          if [ -z "$APP_PATH" ]; then
            echo "::error::App bundle not found"
            exit 1
          fi

          echo "üìç Found app: $APP_PATH"

          # Xo√° ch·ªØ k√Ω c≈©
          find "$APP_PATH" -name "_CodeSignature" -type d -exec rm -rf {} +
          rm -f "$APP_PATH/CodeResources"

          # G·∫Øn provisioning
          cp embedded.mobileprovision "$APP_PATH/embedded.mobileprovision"

          # ƒê·ªïi identifier n·∫øu c√≥ nh·∫≠p
          if [ -n "$NEW_ID" ]; then
            echo "üÜî ƒê·ªïi CFBundleIdentifier th√†nh: $NEW_ID"
            /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $NEW_ID" "$APP_PATH/Info.plist"
          else
            echo "‚ö†Ô∏è Kh√¥ng ƒë·ªïi bundle ID (gi·ªØ nguy√™n)"
          fi

      - name: Import .p12 into temporary keychain
        run: |
          security create-keychain -p temppass temp.keychain
          security unlock-keychain -p temppass temp.keychain
          security import cert.p12 -k temp.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k temppass temp.keychain
          security list-keychains -s temp.keychain login.keychain
          security set-keychain-settings temp.keychain
          echo "‚úÖ Certificate imported"

      - name: Generate minimal entitlements (for enterprise cert)
        run: |
          TEAM_ID="6VN5G6SGEQ"
          cat > entitlements.xcent <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>application-identifier</key>
  <string>$TEAM_ID</string>
  <key>get-task-allow</key>
  <false/>
</dict>
</plist>
EOF
          cat entitlements.xcent

      - name: Recursive codesign
        run: |
          APP_PATH=$(find unpacked/Payload -name "*.app" -print -quit)
          SIGN_ID=$(security find-identity -v temp.keychain | grep "iPhone" | head -n1 | awk '{print $2}')

          echo "üîè Signing with: $SIGN_ID"

          # Sign frameworks
          if [ -d "$APP_PATH/Frameworks" ]; then
            find "$APP_PATH/Frameworks" -name "*.framework" -type d -exec codesign -f -s "$SIGN_ID" --entitlements entitlements.xcent {} \;
          fi

          # Sign extensions
          if [ -d "$APP_PATH/PlugIns" ]; then
            find "$APP_PATH/PlugIns" -name "*.appex" -type d -exec codesign -f -s "$SIGN_ID" --entitlements entitlements.xcent {} \;
          fi

          # Sign main app
          codesign -f -s "$SIGN_ID" --entitlements entitlements.xcent "$APP_PATH"
          echo "‚úÖ Signing completed"

      - name: Repack IPA
        run: |
          cd unpacked
          zip -qr ../signed.ipa Payload
          cd ..

      - name: Upload signed IPA
        run: |
          mv signed.ipa "$IPA_NAME"
          gh release upload "$TAG" "$IPA_NAME" \
            --repo "$REPO" --clobber
          echo "üéâ Signed IPA uploaded"