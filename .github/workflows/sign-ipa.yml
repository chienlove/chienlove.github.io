name: Deep Resign IPA with Bundle ID Replacement

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag containing IPA"
        required: true
      identifier:
        description: "New Bundle Identifier"
        required: true
      old_identifier:
        description: "Old Bundle Identifier to replace (default: net.storeios.chienlove)"
        required: false
        default: "net.storeios.chienlove"

jobs:
  sign:
    runs-on: macos-latest
    permissions:
      contents: write
      packages: read

    env:
      GH_TOKEN: ${{ github.token }}
      REPO: ${{ github.repository }}
      SUPABASE_URL: https://zkbzykamrzvvrhodiypk.supabase.co
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Fetch certificate info from Supabase
        run: |
          response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
            -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
            -H "Accept: application/json" \
            "${SUPABASE_URL}/rest/v1/certificates?select=*")

          http_status=$(echo "$response" | grep HTTP_STATUS: | cut -d':' -f2)
          json_data=$(echo "$response" | sed '/HTTP_STATUS/d')

          if [ "$http_status" -ne 200 ]; then
            echo "::error::Supabase API returned $http_status"
            exit 1
          fi

          echo "$json_data" | jq '.[0]' > cert.json

          echo "CERT_P12_URL=$(jq -r '.p12_url' cert.json)" >> $GITHUB_ENV
          echo "CERT_PROVISION_URL=$(jq -r '.provision_url' cert.json)" >> $GITHUB_ENV
          echo "CERT_PASSWORD=$(jq -r '.password' cert.json)" >> $GITHUB_ENV

      - name: Download certificate & provisioning profile
        run: |
          curl -L "$CERT_P12_URL" -o cert.p12
          curl -L "$CERT_PROVISION_URL" -o profile.mobileprovision

      - name: Set workflow inputs
        run: |
          echo "TAG=${{ github.event.inputs.tag }}" >> $GITHUB_ENV
          echo "IDENTIFIER=${{ github.event.inputs.identifier }}" >> $GITHUB_ENV
          echo "OLD_IDENTIFIER=${{ github.event.inputs.old_identifier || 'net.storeios.chienlove' }}" >> $GITHUB_ENV

      - name: Verify release exists
        run: gh release view "$TAG" --repo "$REPO"

      - name: Download all IPA files from release
        run: |
          gh release download "$TAG" --repo "$REPO" --pattern "*.ipa" --clobber
          COUNT=$(ls *.ipa 2>/dev/null | wc -l)
          if [ "$COUNT" -eq 0 ]; then
            echo "::error::‚ùå No IPA files found in release"
            exit 1
          fi
          echo "üì¶ Found $COUNT IPA files"

      - name: Install dependencies
        run: |
          brew install pkg-config openssl minizip libplist
          pip install biplist

      - name: Install Zsign and search tools
        run: |
          git clone https://github.com/zhlynn/zsign.git
          cd zsign/build/macos
          make clean && make
          sudo cp ../../bin/zsign /usr/local/bin/
          sudo gem install plist_lookup

      - name: Extract Team ID and create entitlements
        run: |
          security cms -D -i profile.mobileprovision > provision.plist
          TEAM_ID=$(plutil -extract TeamIdentifier.0 xml1 -o - provision.plist | xmllint --xpath 'string(//string)' -)
          echo "‚úÖ Extracted TEAM_ID: $TEAM_ID"
          echo "TEAM_ID=$TEAM_ID" >> $GITHUB_ENV

          echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" > entitlements.xcent
          echo "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">" >> entitlements.xcent
          echo "<plist version=\"1.0\">" >> entitlements.xcent
          echo "<dict>" >> entitlements.xcent
          echo "  <key>application-identifier</key>" >> entitlements.xcent
          echo "  <string>$TEAM_ID.$IDENTIFIER</string>" >> entitlements.xcent
          echo "  <key>get-task-allow</key>" >> entitlements.xcent
          echo "  <false/>" >> entitlements.xcent
          echo "  <key>keychain-access-groups</key>" >> entitlements.xcent
          echo "  <array><string>$TEAM_ID.$IDENTIFIER</string></array>" >> entitlements.xcent
          echo "</dict>" >> entitlements.xcent
          echo "</plist>" >> entitlements.xcent

      - name: Deep search and replace Bundle ID
        run: |
          mkdir -p signed
          for IPA in *.ipa; do
            echo "üîç Deep searching for $OLD_IDENTIFIER in $IPA..."
            
            # Extract IPA
            unzip -q "$IPA" -d temp_ipa
            
            # Find .app directory
            APP_DIR=$(find temp_ipa/Payload -name "*.app" -type d -maxdepth 1 | head -1)
            
            # 1. Find all occurrences of old bundle ID
            echo "üîé Locations where $OLD_IDENTIFIER appears:"
            
            # a. In plist files
            find "$APP_DIR" -name "*.plist" -exec grep -l "$OLD_IDENTIFIER" {} \; | while read file; do
              echo "   ‚Ä¢ Plist file: $file"
              plutil -replace CFBundleIdentifier -string "$IDENTIFIER" "$file" 2>/dev/null || true
            done
            
            # b. In binary files (as string)
            find "$APP_DIR" -type f -exec grep -l "$OLD_IDENTIFIER" {} \; | grep -v "\.plist$" | while read file; do
              echo "   ‚Ä¢ Binary file: $file"
              # Use sed to replace in binary files (careful!)
              LC_ALL=C sed -i '' "s/$OLD_IDENTIFIER/$IDENTIFIER/g" "$file" 2>/dev/null || true
            done
            
            # c. In embedded mobileprovision
            if [ -f "$APP_DIR/embedded.mobileprovision" ]; then
              echo "   ‚Ä¢ Found embedded.mobileprovision"
              security cms -D -i "$APP_DIR/embedded.mobileprovision" > temp_prov.plist
              if grep -q "$OLD_IDENTIFIER" temp_prov.plist; then
                echo "‚ö†Ô∏è Old bundle ID found in embedded.mobileprovision - this needs special handling"
              fi
              rm temp_prov.plist
            fi
            
            # 2. Verify all replacements
            echo "‚úÖ Replacement complete. Verifying..."
            OLD_COUNT=$(grep -r "$OLD_IDENTIFIER" temp_ipa/ | wc -l || true)
            if [ "$OLD_COUNT" -gt 0 ]; then
              echo "‚ö†Ô∏è Warning: Found $OLD_COUNT remaining occurrences of $OLD_IDENTIFIER"
              grep -r "$OLD_IDENTIFIER" temp_ipa/ || true
            else
              echo "‚úîÔ∏è Success: No remaining occurrences of $OLD_IDENTIFIER found"
            fi
            
            # Repackage IPA
            cd temp_ipa
            zip -qr "../temp_resigned.ipa" .
            cd ..
            
            # Sign with Zsign
            echo "‚öôÔ∏è Signing $IPA with bundle ID $IDENTIFIER..."
            zsign -k cert.p12 -p "$CERT_PASSWORD" \
                  -m profile.mobileprovision \
                  -e entitlements.xcent \
                  -b "$IDENTIFIER" \
                  --force \
                  -o "signed/$IPA" "temp_resigned.ipa"
            
            # Clean up
            rm -rf temp_ipa temp_resigned.ipa
            
            # Final verification
            echo "üîç Final verification for $IPA..."
            unzip -q "signed/$IPA" -d temp_signed
            SIGNED_APP_DIR=$(find temp_signed/Payload -name "*.app" -type d -maxdepth 1 | head -1)
            echo "‚ÑπÔ∏è Bundle IDs found after signing:"
            plutil -p "$SIGNED_APP_DIR/Info.plist" | grep CFBundleIdentifier
            strings "$SIGNED_APP_DIR/$(basename "$SIGNED_APP_DIR" .app)" | grep "$OLD_IDENTIFIER" && echo "‚ö†Ô∏è Old ID still found in binary" || echo "‚úîÔ∏è No old ID in binary"
            rm -rf temp_signed
          done

      - name: Upload signed IPA files to release
        run: |
          for FILE in signed/*.ipa; do
            echo "‚¨ÜÔ∏è Uploading $FILE..."
            gh release upload "$TAG" "$FILE" --repo "$REPO" --clobber
          done
          echo "‚úÖ All signed IPA files uploaded successfully"