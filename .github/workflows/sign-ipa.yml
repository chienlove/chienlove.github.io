name: Sign IPA in release with Zsign

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag ch·ª©a IPA"
        required: true
      identifier:
        description: "(T√πy ch·ªçn) Bundle Identifier m·ªõi"
        required: false
      selectedIpa:
        description: "(T√πy ch·ªçn) T√™n file IPA c·ª• th·ªÉ c·∫ßn k√Ω"
        required: false
      displayName:
        description: "(T√πy ch·ªçn) T√™n hi·ªÉn th·ªã m·ªõi cho ·ª©ng d·ª•ng"
        required: false

jobs:
  sign:
    name: Sign IPA for ${{ github.event.inputs.tag }}
    runs-on: macos-latest
    permissions:
      contents: write
      packages: read

    env:
      GH_TOKEN: ${{ github.token }}
      REPO: ${{ github.repository }}
      SUPABASE_URL: https://zkbzykamrzvvrhodiypk.supabase.co
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      SELECTED_IPA: ${{ github.event.inputs.selectedIpa }}
      DISPLAY_NAME: ${{ github.event.inputs.displayName }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Fetch certificate info from Supabase
        run: |
          response=$(curl -s -w "\nHTTP_STATUS:%{http_code}" \
            -H "apikey: $SUPABASE_SERVICE_ROLE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
            -H "Accept: application/json" \
            "${SUPABASE_URL}/rest/v1/certificates?select=*")
          http_status=$(echo "$response" | grep HTTP_STATUS: | cut -d':' -f2)
          json_data=$(echo "$response" | sed '/HTTP_STATUS/d')
          if [ "$http_status" -ne 200 ]; then
            echo "::error::Supabase API returned $http_status"
            exit 1
          fi
          echo "$json_data" | jq '.[0]' > cert.json
          echo "CERT_P12_URL=$(jq -r '.p12_url' cert.json)" >> $GITHUB_ENV
          echo "CERT_PROVISION_URL=$(jq -r '.provision_url' cert.json)" >> $GITHUB_ENV
          echo "CERT_PASSWORD=$(jq -r '.password' cert.json)" >> $GITHUB_ENV

      - name: Download certificate and provisioning profile
        run: |
          curl -L "$CERT_P12_URL" -o cert.p12
          curl -L "$CERT_PROVISION_URL" -o embedded.mobileprovision

      - name: Extract TEAM_ID from mobileprovision
        run: |
          security cms -D -i embedded.mobileprovision > provision.plist
          TEAM_ID=$(plutil -extract TeamIdentifier.0 xml1 -o - provision.plist | xmllint --xpath 'string(//string)' -)
          echo "TEAM_ID=$TEAM_ID" >> $GITHUB_ENV

      - name: Set workflow inputs
        run: |
          echo "TAG=${{ github.event.inputs.tag }}" >> $GITHUB_ENV
          echo "INPUT_IDENTIFIER=${{ github.event.inputs.identifier }}" >> $GITHUB_ENV
          echo "SELECTED_IPA=$SELECTED_IPA" >> $GITHUB_ENV
          echo "DISPLAY_NAME=$DISPLAY_NAME" >> $GITHUB_ENV

      - name: Generate shared random (if needed)
        if: ${{ github.event.inputs.identifier == '' }}
        run: |
          RAND=$(openssl rand -hex 3)
          echo "üåÄ Generated common random: $RAND"
          echo "RAND=$RAND" >> $GITHUB_ENV

      - name: Verify release exists
        run: gh release view "$TAG" --repo "$REPO"

      - name: Download IPA file(s)
        run: |
          if [ -n "$SELECTED_IPA" ]; then
            echo "‚¨áÔ∏è Downloading selected IPA: $SELECTED_IPA"
            gh release download "$TAG" --repo "$REPO" --pattern "$SELECTED_IPA" --clobber
          else
            echo "‚¨áÔ∏è Downloading all IPA files"
            gh release download "$TAG" --repo "$REPO" --pattern "*.ipa" --clobber
          fi
          
          COUNT=$(ls *.ipa 2>/dev/null | wc -l)
          if [ "$COUNT" -eq 0 ]; then
            echo "::error::‚ùå No IPA files found in release"
            exit 1
          fi

      - name: Install Zsign
        run: |
          brew install pkg-config openssl minizip
          git clone https://github.com/zhlynn/zsign.git
          cd zsign/build/macos && make clean && make
          sudo cp ../../bin/zsign /usr/local/bin/

      - name: Patch Info.plist & Binary
        run: |
          > id_map.txt
          for IPA in *.ipa; do
            # Skip if this is not the selected IPA (when SELECTED_IPA is specified)
            if [ -n "$SELECTED_IPA" ] && [ "$IPA" != "$SELECTED_IPA" ]; then
              echo "‚è© Skipping $IPA (not selected)"
              continue
            fi

            echo "üì¶ Patching $IPA..."
            APP_NAME=$(basename "$IPA" .ipa)
            WORKDIR="/tmp/zsign_patch_$RANDOM"
            unzip -q "$IPA" -d "$WORKDIR"

            APP_DIR=$(find "$WORKDIR/Payload" -name "*.app" -type d | head -n1)
            MAIN_PLIST="$APP_DIR/Info.plist"
            BINARY_NAME=$(/usr/libexec/PlistBuddy -c "Print :CFBundleExecutable" "$MAIN_PLIST")
            BINARY_PATH="$APP_DIR/$BINARY_NAME"

            # Bundle ID g·ªëc c·ªßa app ch√≠nh
            OLD_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$MAIN_PLIST")
            # B·ªè h·∫≠u t·ªë -storeios.net-xxxx n·∫øu ƒë√£ k√Ω b·∫±ng h·ªá th·ªëng n√†y tr∆∞·ªõc ƒë√≥
            BASE_ID=$(echo "$OLD_ID" | sed -E 's/-storeios\.net(-[a-f0-9]+)?$//')

            # X√°c ƒë·ªãnh FINAL_ID
            if [ -z "$INPUT_IDENTIFIER" ]; then
              FINAL_ID="${BASE_ID}-storeios.net-${RAND}"
            else
              FINAL_ID="$INPUT_IDENTIFIER"
            fi

            # Apply display name if provided
            if [ -n "$DISPLAY_NAME" ]; then
              CURRENT_NAME=$(/usr/libexec/PlistBuddy -c "Print :CFBundleDisplayName" "$MAIN_PLIST" 2>/dev/null || echo "")
              if [ -z "$CURRENT_NAME" ]; then
                /usr/libexec/PlistBuddy -c "Add :CFBundleDisplayName string $DISPLAY_NAME" "$MAIN_PLIST"
              else
                /usr/libexec/PlistBuddy -c "Set :CFBundleDisplayName $DISPLAY_NAME" "$MAIN_PLIST"
              fi
              echo "üÜï Set display name to: $DISPLAY_NAME"
            fi

            echo "üîç OLD Identifier: $OLD_ID"
            echo "üìå New Identifier: $FINAL_ID"

            # ƒê·ªïi bundle id app ch√≠nh
            /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $FINAL_ID" "$MAIN_PLIST"
            # /usr/bin/perl -pi -e "s/\Q$OLD_ID\E/$FINAL_ID/" "$BINARY_PATH"

            echo "üîé Scanning sub-bundles (extensions, widgets, watch, ...)"

            # Duy·ªát t·∫•t c·∫£ Info.plist b√™n trong .app (k·ªÉ c·∫£ PlugIns/*.appex, Watch/*.app, ...)
            while IFS= read -r PLIST_PATH; do
              if [ ! -f "$PLIST_PATH" ]; then
                continue
              fi

              # B·ªè qua main plist (ƒë√£ x·ª≠ l√Ω ·ªü tr√™n)
              if [ "$PLIST_PATH" = "$MAIN_PLIST" ]; then
                continue
              fi

              SUB_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$PLIST_PATH" 2>/dev/null || echo "")
              if [ -z "$SUB_ID" ]; then
                continue
              fi

              NEW_SUB_ID=""

              # 1) N·∫øu id con b·∫±ng h·ªát id ch√≠nh c≈© ‚Üí ƒë·ªïi sang id ch√≠nh m·ªõi
              if [ "$SUB_ID" = "$OLD_ID" ]; then
                NEW_SUB_ID="$FINAL_ID"
              # 2) N·∫øu id con d·∫°ng OLD_ID.suffix ‚Üí ƒë·ªïi th√†nh FINAL_ID.suffix
              elif [[ "$SUB_ID" == "$OLD_ID."* ]]; then
                SUFFIX="${SUB_ID#$OLD_ID}"
                NEW_SUB_ID="${FINAL_ID}${SUFFIX}"
              fi

              if [ -n "$NEW_SUB_ID" ]; then
                /usr/libexec/PlistBuddy -c "Set :CFBundleIdentifier $NEW_SUB_ID" "$PLIST_PATH"
                echo "   üîß Patched bundle id: $SUB_ID -> $NEW_SUB_ID (plist: $PLIST_PATH)"
              else
                echo "   ‚ÑπÔ∏è Keep sub-bundle ID unchanged: $SUB_ID"
              fi
            done < <(find "$APP_DIR" -name "Info.plist" -type f)

            echo "$IPA|$FINAL_ID" >> id_map.txt

            OUTPUT_PATH="$RUNNER_TEMP/$APP_NAME-patched.ipa"
            cd "$WORKDIR"
            zip -qr9 "$OUTPUT_PATH" Payload
            cd -
            mv "$OUTPUT_PATH" "$IPA"
            rm -rf "$WORKDIR"
          done

      - name: Sign IPA files
        run: |
          while IFS='|' read -r IPA FINAL_ID; do
            APP_NAME=$(basename "$IPA" .ipa)
            TMP_OUT="$RUNNER_TEMP/$APP_NAME-signed.ipa"

            echo "üîß Signing $IPA with Zsign..."
            zsign -f -z 9 -k cert.p12 -p "$CERT_PASSWORD" -m embedded.mobileprovision \
              -b "$FINAL_ID" -o "$TMP_OUT" "$IPA"

            mv "$TMP_OUT" "$IPA"
          done < id_map.txt

      - name: Upload signed IPA
        run: |
          while IFS='|' read -r IPA FINAL_ID; do
            FILENAME=$(basename "$IPA")
            gh release upload "$TAG" "$FILENAME" --repo "$REPO" --clobber
          done < id_map.txt

      - name: Generate plist with version & icon
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          mkdir -p secure/plist public/icons

          BASE_URL="https://github.com/$REPO/releases/download/$TAG"
          ICON_BASE_URL="https://storeios.net/icons"

          # keep track of new icons to add/commit (we will NOT add icons that already exist)
          NEW_ICONS=()

          # keep track whether any plist changed (we'll check files after loop)
          PLIST_CHANGED=0

          while IFS='|' read -r IPA FINAL_ID; do
            FILENAME=$(basename "$IPA")
            APP_NAME="${FILENAME%.ipa}"
            WORKDIR="/tmp/zsign_meta_$RANDOM"
            unzip -q "$IPA" -d "$WORKDIR"

            APP_DIR=$(find "$WORKDIR/Payload" -name "*.app" -type d | head -n1)
            MAIN_PLIST="$APP_DIR/Info.plist"

            VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$MAIN_PLIST" || echo "1.0.0")

            ICON_PATH=$(find "$APP_DIR" -type f -name "*AppIcon60x60@2x*.png" | head -n1)
            ICON_NAME="${APP_NAME}.png"
            ICON_OUT="public/icons/$ICON_NAME"

            if [ -f "$ICON_PATH" ]; then
              # If icon with same name already exists in repo, skip copying/committing it
              if [ -f "$ICON_OUT" ]; then
                echo "üü° Icon $ICON_OUT already exists in repository -- skipping copy and commit for this icon."
              else
                cp "$ICON_PATH" "$ICON_OUT"
                echo "üñºÔ∏è Extracted icon: $ICON_OUT"
                NEW_ICONS+=("$ICON_OUT")
              fi
            else
              echo "üì¶ Kh√¥ng t√¨m th·∫•y icon ph√π h·ª£p cho $APP_NAME."
            fi

            PLIST_NAME="${APP_NAME}.plist"
            PLIST_PATH="secure/plist/$PLIST_NAME"

            # generate plist (always overwrite)
            echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" > "$PLIST_PATH"
            echo "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">" >> "$PLIST_PATH"
            echo "<plist version=\"1.0\"><dict>" >> "$PLIST_PATH"
            echo "  <key>items</key><array><dict>" >> "$PLIST_PATH"
            echo "    <key>assets</key><array>" >> "$PLIST_PATH"

            echo "      <dict>" >> "$PLIST_PATH"
            echo "        <key>kind</key><string>software-package</string>" >> "$PLIST_PATH"
            echo "        <key>url</key><string>$BASE_URL/$FILENAME</string>" >> "$PLIST_PATH"
            echo "      </dict>" >> "$PLIST_PATH"

            if [ -f "$ICON_OUT" ]; then
              echo "      <dict>" >> "$PLIST_PATH"
              echo "        <key>kind</key><string>display-image</string>" >> "$PLIST_PATH"
              echo "        <key>needs-shine</key><false/>" >> "$PLIST_PATH"
              echo "        <key>url</key><string>$ICON_BASE_URL/$ICON_NAME</string>" >> "$PLIST_PATH"
              echo "      </dict>" >> "$PLIST_PATH"
            fi

            echo "    </array>" >> "$PLIST_PATH"
            echo "    <key>metadata</key><dict>" >> "$PLIST_PATH"
            echo "      <key>bundle-identifier</key><string>$FINAL_ID</string>" >> "$PLIST_PATH"
            echo "      <key>bundle-version</key><string>$VERSION</string>" >> "$PLIST_PATH"
            echo "      <key>kind</key><string>software</string>" >> "$PLIST_PATH"
            echo "      <key>title</key><string>$APP_NAME</string>" >> "$PLIST_PATH"
            echo "    </dict>" >> "$PLIST_PATH"
            echo "  </dict></array></dict></plist>" >> "$PLIST_PATH"

            # mark that plist(s) were generated/changed
            PLIST_CHANGED=1

            rm -rf "$WORKDIR"
          done < id_map.txt

          # Add only new icons (skip icons that already existed)
          if [ ${#NEW_ICONS[@]} -gt 0 ]; then
            git add "${NEW_ICONS[@]}"
          fi

          # Add all generated plists (we always overwrite plist files)
          git add secure/plist/*.plist || true

          # Commit only if there is something to commit
          if git diff --cached --quiet; then
            echo "No new icons or plist changes to commit."
          else
            git commit -m "ü§ñ Update plist & icon for tag $TAG" || echo "No changes to commit"
            git push || echo "Push failed or nothing to push"
          fi