{"version":3,"sources":["@wordpress/components/src/query-controls/terms.ts"],"names":["ensureParentsAreDefined","terms","every","term","parent","buildTermsTree","flatTerms","flatTermsWithParentAndChildren","map","children","id","String","termsByParent","reduce","acc","push","fillWithChildren","length"],"mappings":"AAAA;AACA;AACA;AAQA,MAAMA,uBAAuB,GAC5BC,KAD+B,IAEoC;AACnE,SAAOA,KAAK,CAACC,KAAN,CAAeC,IAAF,IAAYA,IAAI,CAACC,MAAL,KAAgB,IAAzC,CAAP;AACA,CAJD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASC,cAAT,CAAyBC,SAAzB,EAAuE;AAC7E,QAAMC,8BAA2D,GAChED,SAAS,CAACE,GAAV,CAAiBL,IAAF,KAAc;AAC5BM,IAAAA,QAAQ,EAAE,EADkB;AAE5BL,IAAAA,MAAM,EAAE,IAFoB;AAG5B,OAAGD,IAHyB;AAI5BO,IAAAA,EAAE,EAAEC,MAAM,CAAER,IAAI,CAACO,EAAP;AAJkB,GAAd,CAAf,CADD,CAD6E,CAS7E;AACA;AACA;AACA;;AACA,MAAK,CAAEV,uBAAuB,CAAEO,8BAAF,CAA9B,EAAmE;AAClE,WAAOA,8BAAP;AACA;;AAED,QAAMK,aAAa,GAAGL,8BAA8B,CAACM,MAA/B,CACrB,CAAEC,GAAF,EAAsBX,IAAtB,KAAgC;AAC/B,UAAM;AAAEC,MAAAA;AAAF,QAAaD,IAAnB;;AACA,QAAK,CAAEW,GAAG,CAAEV,MAAF,CAAV,EAAuB;AACtBU,MAAAA,GAAG,CAAEV,MAAF,CAAH,GAAgB,EAAhB;AACA;;AACDU,IAAAA,GAAG,CAAEV,MAAF,CAAH,CAAcW,IAAd,CAAoBZ,IAApB;AACA,WAAOW,GAAP;AACA,GARoB,EASrB,EATqB,CAAtB;;AAYA,QAAME,gBAAgB,GACrBf,KADwB,IAES;AACjC,WAAOA,KAAK,CAACO,GAAN,CAAaL,IAAF,IAAY;AAC7B,YAAMM,QAAQ,GAAGG,aAAa,CAAET,IAAI,CAACO,EAAP,CAA9B;AACA,aAAO,EACN,GAAGP,IADG;AAENM,QAAAA,QAAQ,EACPA,QAAQ,IAAIA,QAAQ,CAACQ,MAArB,GACGD,gBAAgB,CAAEP,QAAF,CADnB,GAEG;AALE,OAAP;AAOA,KATM,CAAP;AAUA,GAbD;;AAeA,SAAOO,gBAAgB,CAAEJ,aAAa,CAAE,GAAF,CAAb,IAAwB,EAA1B,CAAvB;AACA","sourcesContent":["/**\n * Internal dependencies\n */\nimport type {\n\tAuthor,\n\tCategory,\n\tTermWithParentAndChildren,\n\tTermsByParent,\n} from './types';\n\nconst ensureParentsAreDefined = (\n\tterms: TermWithParentAndChildren[]\n): terms is ( TermWithParentAndChildren & { parent: number } )[] => {\n\treturn terms.every( ( term ) => term.parent !== null );\n};\n/**\n * Returns terms in a tree form.\n *\n * @param flatTerms Array of terms in flat format.\n *\n * @return Terms in tree format.\n */\nexport function buildTermsTree( flatTerms: readonly ( Author | Category )[] ) {\n\tconst flatTermsWithParentAndChildren: TermWithParentAndChildren[] =\n\t\tflatTerms.map( ( term ) => ( {\n\t\t\tchildren: [],\n\t\t\tparent: null,\n\t\t\t...term,\n\t\t\tid: String( term.id ),\n\t\t} ) );\n\n\t// We use a custom type guard here to ensure that the parent property is\n\t// defined on all terms. The type of the `parent` property is `number | null`\n\t// and we need to ensure that it is `number`. This is because we use the\n\t// `parent` property as a key in the `termsByParent` object.\n\tif ( ! ensureParentsAreDefined( flatTermsWithParentAndChildren ) ) {\n\t\treturn flatTermsWithParentAndChildren;\n\t}\n\n\tconst termsByParent = flatTermsWithParentAndChildren.reduce(\n\t\t( acc: TermsByParent, term ) => {\n\t\t\tconst { parent } = term;\n\t\t\tif ( ! acc[ parent ] ) {\n\t\t\t\tacc[ parent ] = [];\n\t\t\t}\n\t\t\tacc[ parent ].push( term );\n\t\t\treturn acc;\n\t\t},\n\t\t{}\n\t);\n\n\tconst fillWithChildren = (\n\t\tterms: TermWithParentAndChildren[]\n\t): TermWithParentAndChildren[] => {\n\t\treturn terms.map( ( term ) => {\n\t\t\tconst children = termsByParent[ term.id ];\n\t\t\treturn {\n\t\t\t\t...term,\n\t\t\t\tchildren:\n\t\t\t\t\tchildren && children.length\n\t\t\t\t\t\t? fillWithChildren( children )\n\t\t\t\t\t\t: [],\n\t\t\t};\n\t\t} );\n\t};\n\n\treturn fillWithChildren( termsByParent[ '0' ] || [] );\n}\n"]}