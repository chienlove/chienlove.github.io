"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NavigatorScreen = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _framerMotion = require("framer-motion");

var _react = require("@emotion/react");

var _dom = require("@wordpress/dom");

var _compose = require("@wordpress/compose");

var _i18n = require("@wordpress/i18n");

var _escapeHtml = require("@wordpress/escape-html");

var _context = require("../../ui/context");

var _useCx = require("../../utils/hooks/use-cx");

var _view = require("../../view");

var _context2 = require("../context");

function _EMOTION_STRINGIFIED_CSS_ERROR__() { return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop)."; }

const animationEnterDelay = 0;
const animationEnterDuration = 0.14;
const animationExitDuration = 0.14;
const animationExitDelay = 0; // Props specific to `framer-motion` can't be currently passed to `NavigatorScreen`,
// as some of them would overlap with HTML props (e.g. `onAnimationStart`, ...)

var _ref = process.env.NODE_ENV === "production" ? {
  name: "14x3t6z",
  styles: "overflow-x:auto;max-height:100%"
} : {
  name: "1ulogbc-classes",
  styles: "overflow-x:auto;max-height:100%;label:classes;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkB3b3JkcHJlc3MvY29tcG9uZW50cy9zcmMvbmF2aWdhdG9yL25hdmlnYXRvci1zY3JlZW4vY29tcG9uZW50LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE2RUkiLCJmaWxlIjoiQHdvcmRwcmVzcy9jb21wb25lbnRzL3NyYy9uYXZpZ2F0b3IvbmF2aWdhdG9yLXNjcmVlbi9jb21wb25lbnQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHR5cGUgeyBGb3J3YXJkZWRSZWYgfSBmcm9tICdyZWFjdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5pbXBvcnQgeyBtb3Rpb24sIE1vdGlvblByb3BzIH0gZnJvbSAnZnJhbWVyLW1vdGlvbic7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbi8qKlxuICogV29yZFByZXNzIGRlcGVuZGVuY2llc1xuICovXG5pbXBvcnQgeyBmb2N1cyB9IGZyb20gJ0B3b3JkcHJlc3MvZG9tJztcbmltcG9ydCB7XG5cdHVzZUNvbnRleHQsXG5cdHVzZUVmZmVjdCxcblx0dXNlTWVtbyxcblx0dXNlUmVmLFxuXHR1c2VJZCxcbn0gZnJvbSAnQHdvcmRwcmVzcy9lbGVtZW50JztcbmltcG9ydCB7IHVzZVJlZHVjZWRNb3Rpb24sIHVzZU1lcmdlUmVmcyB9IGZyb20gJ0B3b3JkcHJlc3MvY29tcG9zZSc7XG5pbXBvcnQgeyBpc1JUTCB9IGZyb20gJ0B3b3JkcHJlc3MvaTE4bic7XG5pbXBvcnQgeyBlc2NhcGVBdHRyaWJ1dGUgfSBmcm9tICdAd29yZHByZXNzL2VzY2FwZS1odG1sJztcblxuLyoqXG4gKiBJbnRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IHtcblx0Y29udGV4dENvbm5lY3QsXG5cdHVzZUNvbnRleHRTeXN0ZW0sXG5cdFdvcmRQcmVzc0NvbXBvbmVudFByb3BzLFxufSBmcm9tICcuLi8uLi91aS9jb250ZXh0JztcbmltcG9ydCB7IHVzZUN4IH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9va3MvdXNlLWN4JztcbmltcG9ydCB7IFZpZXcgfSBmcm9tICcuLi8uLi92aWV3JztcbmltcG9ydCB7IE5hdmlnYXRvckNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB0eXBlIHsgTmF2aWdhdG9yU2NyZWVuUHJvcHMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGFuaW1hdGlvbkVudGVyRGVsYXkgPSAwO1xuY29uc3QgYW5pbWF0aW9uRW50ZXJEdXJhdGlvbiA9IDAuMTQ7XG5jb25zdCBhbmltYXRpb25FeGl0RHVyYXRpb24gPSAwLjE0O1xuY29uc3QgYW5pbWF0aW9uRXhpdERlbGF5ID0gMDtcblxuLy8gUHJvcHMgc3BlY2lmaWMgdG8gYGZyYW1lci1tb3Rpb25gIGNhbid0IGJlIGN1cnJlbnRseSBwYXNzZWQgdG8gYE5hdmlnYXRvclNjcmVlbmAsXG4vLyBhcyBzb21lIG9mIHRoZW0gd291bGQgb3ZlcmxhcCB3aXRoIEhUTUwgcHJvcHMgKGUuZy4gYG9uQW5pbWF0aW9uU3RhcnRgLCAuLi4pXG50eXBlIFByb3BzID0gT21pdDxcblx0V29yZFByZXNzQ29tcG9uZW50UHJvcHM8IE5hdmlnYXRvclNjcmVlblByb3BzLCAnZGl2JywgZmFsc2UgPixcblx0RXhjbHVkZTwga2V5b2YgTW90aW9uUHJvcHMsICdzdHlsZScgfCAnY2hpbGRyZW4nID5cbj47XG5cbmZ1bmN0aW9uIFVuY29ubmVjdGVkTmF2aWdhdG9yU2NyZWVuKFxuXHRwcm9wczogUHJvcHMsXG5cdGZvcndhcmRlZFJlZjogRm9yd2FyZGVkUmVmPCBhbnkgPlxuKSB7XG5cdGNvbnN0IHNjcmVlbklkID0gdXNlSWQoKTtcblx0Y29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBwYXRoLCAuLi5vdGhlclByb3BzIH0gPSB1c2VDb250ZXh0U3lzdGVtKFxuXHRcdHByb3BzLFxuXHRcdCdOYXZpZ2F0b3JTY3JlZW4nXG5cdCk7XG5cblx0Y29uc3QgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB1c2VSZWR1Y2VkTW90aW9uKCk7XG5cdGNvbnN0IHsgbG9jYXRpb24sIG1hdGNoLCBhZGRTY3JlZW4sIHJlbW92ZVNjcmVlbiB9ID1cblx0XHR1c2VDb250ZXh0KCBOYXZpZ2F0b3JDb250ZXh0ICk7XG5cdGNvbnN0IGlzTWF0Y2ggPSBtYXRjaCA9PT0gc2NyZWVuSWQ7XG5cdGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VSZWY8IEhUTUxEaXZFbGVtZW50ID4oIG51bGwgKTtcblxuXHR1c2VFZmZlY3QoICgpID0+IHtcblx0XHRjb25zdCBzY3JlZW4gPSB7XG5cdFx0XHRpZDogc2NyZWVuSWQsXG5cdFx0XHRwYXRoOiBlc2NhcGVBdHRyaWJ1dGUoIHBhdGggKSxcblx0XHR9O1xuXHRcdGFkZFNjcmVlbiggc2NyZWVuICk7XG5cdFx0cmV0dXJuICgpID0+IHJlbW92ZVNjcmVlbiggc2NyZWVuICk7XG5cdH0sIFsgc2NyZWVuSWQsIHBhdGgsIGFkZFNjcmVlbiwgcmVtb3ZlU2NyZWVuIF0gKTtcblxuXHRjb25zdCBjeCA9IHVzZUN4KCk7XG5cdGNvbnN0IGNsYXNzZXMgPSB1c2VNZW1vKFxuXHRcdCgpID0+XG5cdFx0XHRjeChcblx0XHRcdFx0Y3NzKCB7XG5cdFx0XHRcdFx0Ly8gRW5zdXJlcyBob3Jpem9udGFsIG92ZXJmbG93IGlzIHZpc3VhbGx5IGFjY2Vzc2libGUuXG5cdFx0XHRcdFx0b3ZlcmZsb3dYOiAnYXV0bycsXG5cdFx0XHRcdFx0Ly8gSW4gY2FzZSB0aGUgcm9vdCBoYXMgYSBoZWlnaHQsIGl0IHNob3VsZCBub3QgYmUgZXhjZWVkZWQuXG5cdFx0XHRcdFx0bWF4SGVpZ2h0OiAnMTAwJScsXG5cdFx0XHRcdH0gKSxcblx0XHRcdFx0Y2xhc3NOYW1lXG5cdFx0XHQpLFxuXHRcdFsgY2xhc3NOYW1lLCBjeCBdXG5cdCk7XG5cblx0Y29uc3QgbG9jYXRpb25SZWYgPSB1c2VSZWYoIGxvY2F0aW9uICk7XG5cblx0dXNlRWZmZWN0KCAoKSA9PiB7XG5cdFx0bG9jYXRpb25SZWYuY3VycmVudCA9IGxvY2F0aW9uO1xuXHR9LCBbIGxvY2F0aW9uIF0gKTtcblxuXHQvLyBGb2N1cyByZXN0b3JhdGlvblxuXHRjb25zdCBpc0luaXRpYWxMb2NhdGlvbiA9IGxvY2F0aW9uLmlzSW5pdGlhbCAmJiAhIGxvY2F0aW9uLmlzQmFjaztcblx0dXNlRWZmZWN0KCAoKSA9PiB7XG5cdFx0Ly8gT25seSBhdHRlbXB0IHRvIHJlc3RvcmUgZm9jdXM6XG5cdFx0Ly8gLSBpZiB0aGUgY3VycmVudCBsb2NhdGlvbiBpcyBub3QgdGhlIGluaXRpYWwgb25lICh0byBhdm9pZCBtb3ZpbmcgZm9jdXMgb24gcGFnZSBsb2FkKVxuXHRcdC8vIC0gd2hlbiB0aGUgc2NyZWVuIGJlY29tZXMgdmlzaWJsZVxuXHRcdC8vIC0gaWYgdGhlIHdyYXBwZXIgcmVmIGhhcyBiZWVuIGFzc2lnbmVkXG5cdFx0Ly8gLSBpZiBmb2N1cyBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJlc3RvcmVkIGZvciB0aGUgY3VycmVudCBsb2NhdGlvblxuXHRcdC8vIC0gaWYgdGhlIGBza2lwRm9jdXNgIG9wdGlvbiBpcyBub3Qgc2V0IHRvIGB0cnVlYC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB3ZSB0cmlnZ2VyIHRoZSBuYXZpZ2F0aW9uIG91dHNpZGUgb2YgTmF2aWdhdG9yU2NyZWVuLlxuXHRcdGlmIChcblx0XHRcdGlzSW5pdGlhbExvY2F0aW9uIHx8XG5cdFx0XHQhIGlzTWF0Y2ggfHxcblx0XHRcdCEgd3JhcHBlclJlZi5jdXJyZW50IHx8XG5cdFx0XHRsb2NhdGlvblJlZi5jdXJyZW50Lmhhc1Jlc3RvcmVkRm9jdXMgfHxcblx0XHRcdGxvY2F0aW9uLnNraXBGb2N1c1xuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB3cmFwcGVyUmVmLmN1cnJlbnQub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0Ly8gSWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQgd2l0aGluIHRoZSB3cmFwcGVyIGRvIG5vdCBmb2N1cyB0aGVcblx0XHQvLyBlbGVtZW50LiBUaGlzIHByZXZlbnRzIGlucHV0cyBvciBidXR0b25zIGZyb20gbG9zaW5nIGZvY3VzIHVubmVjZXNzYXJpbHkuXG5cdFx0aWYgKCB3cmFwcGVyUmVmLmN1cnJlbnQuY29udGFpbnMoIGFjdGl2ZUVsZW1lbnQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgZWxlbWVudFRvRm9jdXM6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cblx0XHQvLyBXaGVuIG5hdmlnYXRpbmcgYmFjaywgaWYgYSBzZWxlY3RvciBpcyBwcm92aWRlZCwgdXNlIGl0IHRvIGxvb2sgZm9yIHRoZVxuXHRcdC8vIHRhcmdldCBlbGVtZW50IChhc3N1bWVkIHRvIGJlIGEgbm9kZSBpbnNpZGUgdGhlIGN1cnJlbnQgTmF2aWdhdG9yU2NyZWVuKVxuXHRcdGlmICggbG9jYXRpb24uaXNCYWNrICYmIGxvY2F0aW9uPy5mb2N1c1RhcmdldFNlbGVjdG9yICkge1xuXHRcdFx0ZWxlbWVudFRvRm9jdXMgPSB3cmFwcGVyUmVmLmN1cnJlbnQucXVlcnlTZWxlY3Rvcihcblx0XHRcdFx0bG9jYXRpb24uZm9jdXNUYXJnZXRTZWxlY3RvclxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgcHJldmlvdXMgcXVlcnkgZGlkbid0IHJ1biBvciBmaW5kIGFueSBlbGVtZW50IHRvIGZvY3VzLCBmYWxsYmFja1xuXHRcdC8vIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IGluIHRoZSBzY3JlZW4gKG9yIHRoZSBzY3JlZW4gaXRzZWxmKS5cblx0XHRpZiAoICEgZWxlbWVudFRvRm9jdXMgKSB7XG5cdFx0XHRjb25zdCBmaXJzdFRhYmJhYmxlID0gKFxuXHRcdFx0XHRmb2N1cy50YWJiYWJsZS5maW5kKCB3cmFwcGVyUmVmLmN1cnJlbnQgKSBhcyBIVE1MRWxlbWVudFtdXG5cdFx0XHQgKVsgMCBdO1xuXHRcdFx0ZWxlbWVudFRvRm9jdXMgPSBmaXJzdFRhYmJhYmxlID8/IHdyYXBwZXJSZWYuY3VycmVudDtcblx0XHR9XG5cblx0XHRsb2NhdGlvblJlZi5jdXJyZW50Lmhhc1Jlc3RvcmVkRm9jdXMgPSB0cnVlO1xuXHRcdGVsZW1lbnRUb0ZvY3VzLmZvY3VzKCk7XG5cdH0sIFtcblx0XHRpc0luaXRpYWxMb2NhdGlvbixcblx0XHRpc01hdGNoLFxuXHRcdGxvY2F0aW9uLmlzQmFjayxcblx0XHRsb2NhdGlvbi5mb2N1c1RhcmdldFNlbGVjdG9yLFxuXHRcdGxvY2F0aW9uLnNraXBGb2N1cyxcblx0XSApO1xuXG5cdGNvbnN0IG1lcmdlZFdyYXBwZXJSZWYgPSB1c2VNZXJnZVJlZnMoIFsgZm9yd2FyZGVkUmVmLCB3cmFwcGVyUmVmIF0gKTtcblxuXHRpZiAoICEgaXNNYXRjaCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICggcHJlZmVyc1JlZHVjZWRNb3Rpb24gKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxWaWV3XG5cdFx0XHRcdHJlZj17IG1lcmdlZFdyYXBwZXJSZWYgfVxuXHRcdFx0XHRjbGFzc05hbWU9eyBjbGFzc2VzIH1cblx0XHRcdFx0eyAuLi5vdGhlclByb3BzIH1cblx0XHRcdD5cblx0XHRcdFx0eyBjaGlsZHJlbiB9XG5cdFx0XHQ8L1ZpZXc+XG5cdFx0KTtcblx0fVxuXG5cdGNvbnN0IGFuaW1hdGUgPSB7XG5cdFx0b3BhY2l0eTogMSxcblx0XHR0cmFuc2l0aW9uOiB7XG5cdFx0XHRkZWxheTogYW5pbWF0aW9uRW50ZXJEZWxheSxcblx0XHRcdGR1cmF0aW9uOiBhbmltYXRpb25FbnRlckR1cmF0aW9uLFxuXHRcdFx0ZWFzZTogJ2Vhc2VJbk91dCcsXG5cdFx0fSxcblx0XHR4OiAwLFxuXHR9O1xuXHQvLyBEaXNhYmxlIHRoZSBpbml0aWFsIGFuaW1hdGlvbiBpZiB0aGUgc2NyZWVuIGlzIHRoZSB2ZXJ5IGZpcnN0IHNjcmVlbiB0byBiZVxuXHQvLyByZW5kZXJlZCB3aXRoaW4gdGhlIGN1cnJlbnQgYE5hdmlnYXRvclByb3ZpZGVyYC5cblx0Y29uc3QgaW5pdGlhbCA9XG5cdFx0bG9jYXRpb24uaXNJbml0aWFsICYmICEgbG9jYXRpb24uaXNCYWNrXG5cdFx0XHQ/IGZhbHNlXG5cdFx0XHQ6IHtcblx0XHRcdFx0XHRvcGFjaXR5OiAwLFxuXHRcdFx0XHRcdHg6XG5cdFx0XHRcdFx0XHQoIGlzUlRMKCkgJiYgbG9jYXRpb24uaXNCYWNrICkgfHxcblx0XHRcdFx0XHRcdCggISBpc1JUTCgpICYmICEgbG9jYXRpb24uaXNCYWNrIClcblx0XHRcdFx0XHRcdFx0PyA1MFxuXHRcdFx0XHRcdFx0XHQ6IC01MCxcblx0XHRcdCAgfTtcblx0Y29uc3QgZXhpdCA9IHtcblx0XHRkZWxheTogYW5pbWF0aW9uRXhpdERlbGF5LFxuXHRcdG9wYWNpdHk6IDAsXG5cdFx0eDpcblx0XHRcdCggISBpc1JUTCgpICYmIGxvY2F0aW9uLmlzQmFjayApIHx8ICggaXNSVEwoKSAmJiAhIGxvY2F0aW9uLmlzQmFjayApXG5cdFx0XHRcdD8gNTBcblx0XHRcdFx0OiAtNTAsXG5cdFx0dHJhbnNpdGlvbjoge1xuXHRcdFx0ZHVyYXRpb246IGFuaW1hdGlvbkV4aXREdXJhdGlvbixcblx0XHRcdGVhc2U6ICdlYXNlSW5PdXQnLFxuXHRcdH0sXG5cdH07XG5cblx0Y29uc3QgYW5pbWF0ZWRQcm9wcyA9IHtcblx0XHRhbmltYXRlLFxuXHRcdGV4aXQsXG5cdFx0aW5pdGlhbCxcblx0fTtcblxuXHRyZXR1cm4gKFxuXHRcdDxtb3Rpb24uZGl2XG5cdFx0XHRyZWY9eyBtZXJnZWRXcmFwcGVyUmVmIH1cblx0XHRcdGNsYXNzTmFtZT17IGNsYXNzZXMgfVxuXHRcdFx0eyAuLi5vdGhlclByb3BzIH1cblx0XHRcdHsgLi4uYW5pbWF0ZWRQcm9wcyB9XG5cdFx0PlxuXHRcdFx0eyBjaGlsZHJlbiB9XG5cdFx0PC9tb3Rpb24uZGl2PlxuXHQpO1xufVxuXG4vKipcbiAqIFRoZSBgTmF2aWdhdG9yU2NyZWVuYCBjb21wb25lbnQgcmVwcmVzZW50cyBhIHNpbmdsZSB2aWV3L3NjcmVlbi9wYW5lbCBhbmRcbiAqIHNob3VsZCBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIGBOYXZpZ2F0b3JQcm92aWRlcmAsIHRoZVxuICogYE5hdmlnYXRvckJ1dHRvbmAgYW5kIHRoZSBgTmF2aWdhdG9yQmFja0J1dHRvbmAgY29tcG9uZW50cyAob3IgdGhlIGB1c2VOYXZpZ2F0b3JgXG4gKiBob29rKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQge1xuICogICBfX2V4cGVyaW1lbnRhbE5hdmlnYXRvclByb3ZpZGVyIGFzIE5hdmlnYXRvclByb3ZpZGVyLFxuICogICBfX2V4cGVyaW1lbnRhbE5hdmlnYXRvclNjcmVlbiBhcyBOYXZpZ2F0b3JTY3JlZW4sXG4gKiAgIF9fZXhwZXJpbWVudGFsTmF2aWdhdG9yQnV0dG9uIGFzIE5hdmlnYXRvckJ1dHRvbixcbiAqICAgX19leHBlcmltZW50YWxOYXZpZ2F0b3JCYWNrQnV0dG9uIGFzIE5hdmlnYXRvckJhY2tCdXR0b24sXG4gKiB9IGZyb20gJ0B3b3JkcHJlc3MvY29tcG9uZW50cyc7XG4gKlxuICogY29uc3QgTXlOYXZpZ2F0aW9uID0gKCkgPT4gKFxuICogICA8TmF2aWdhdG9yUHJvdmlkZXIgaW5pdGlhbFBhdGg9XCIvXCI+XG4gKiAgICAgPE5hdmlnYXRvclNjcmVlbiBwYXRoPVwiL1wiPlxuICogICAgICAgPHA+VGhpcyBpcyB0aGUgaG9tZSBzY3JlZW4uPC9wPlxuICogICAgICAgIDxOYXZpZ2F0b3JCdXR0b24gcGF0aD1cIi9jaGlsZFwiPlxuICogICAgICAgICAgTmF2aWdhdGUgdG8gY2hpbGQgc2NyZWVuLlxuICogICAgICAgPC9OYXZpZ2F0b3JCdXR0b24+XG4gKiAgICAgPC9OYXZpZ2F0b3JTY3JlZW4+XG4gKlxuICogICAgIDxOYXZpZ2F0b3JTY3JlZW4gcGF0aD1cIi9jaGlsZFwiPlxuICogICAgICAgPHA+VGhpcyBpcyB0aGUgY2hpbGQgc2NyZWVuLjwvcD5cbiAqICAgICAgIDxOYXZpZ2F0b3JCYWNrQnV0dG9uPlxuICogICAgICAgICBHbyBiYWNrXG4gKiAgICAgICA8L05hdmlnYXRvckJhY2tCdXR0b24+XG4gKiAgICAgPC9OYXZpZ2F0b3JTY3JlZW4+XG4gKiAgIDwvTmF2aWdhdG9yUHJvdmlkZXI+XG4gKiApO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBOYXZpZ2F0b3JTY3JlZW4gPSBjb250ZXh0Q29ubmVjdChcblx0VW5jb25uZWN0ZWROYXZpZ2F0b3JTY3JlZW4sXG5cdCdOYXZpZ2F0b3JTY3JlZW4nXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0b3JTY3JlZW47XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};

function UnconnectedNavigatorScreen(props, forwardedRef) {
  const screenId = (0, _element.useId)();
  const {
    children,
    className,
    path,
    ...otherProps
  } = (0, _context.useContextSystem)(props, 'NavigatorScreen');
  const prefersReducedMotion = (0, _compose.useReducedMotion)();
  const {
    location,
    match,
    addScreen,
    removeScreen
  } = (0, _element.useContext)(_context2.NavigatorContext);
  const isMatch = match === screenId;
  const wrapperRef = (0, _element.useRef)(null);
  (0, _element.useEffect)(() => {
    const screen = {
      id: screenId,
      path: (0, _escapeHtml.escapeAttribute)(path)
    };
    addScreen(screen);
    return () => removeScreen(screen);
  }, [screenId, path, addScreen, removeScreen]);
  const cx = (0, _useCx.useCx)();
  const classes = (0, _element.useMemo)(() => cx(_ref, className), [className, cx]);
  const locationRef = (0, _element.useRef)(location);
  (0, _element.useEffect)(() => {
    locationRef.current = location;
  }, [location]); // Focus restoration

  const isInitialLocation = location.isInitial && !location.isBack;
  (0, _element.useEffect)(() => {
    // Only attempt to restore focus:
    // - if the current location is not the initial one (to avoid moving focus on page load)
    // - when the screen becomes visible
    // - if the wrapper ref has been assigned
    // - if focus hasn't already been restored for the current location
    // - if the `skipFocus` option is not set to `true`. This is useful when we trigger the navigation outside of NavigatorScreen.
    if (isInitialLocation || !isMatch || !wrapperRef.current || locationRef.current.hasRestoredFocus || location.skipFocus) {
      return;
    }

    const activeElement = wrapperRef.current.ownerDocument.activeElement; // If an element is already focused within the wrapper do not focus the
    // element. This prevents inputs or buttons from losing focus unnecessarily.

    if (wrapperRef.current.contains(activeElement)) {
      return;
    }

    let elementToFocus = null; // When navigating back, if a selector is provided, use it to look for the
    // target element (assumed to be a node inside the current NavigatorScreen)

    if (location.isBack && location !== null && location !== void 0 && location.focusTargetSelector) {
      elementToFocus = wrapperRef.current.querySelector(location.focusTargetSelector);
    } // If the previous query didn't run or find any element to focus, fallback
    // to the first tabbable element in the screen (or the screen itself).


    if (!elementToFocus) {
      const firstTabbable = _dom.focus.tabbable.find(wrapperRef.current)[0];

      elementToFocus = firstTabbable !== null && firstTabbable !== void 0 ? firstTabbable : wrapperRef.current;
    }

    locationRef.current.hasRestoredFocus = true;
    elementToFocus.focus();
  }, [isInitialLocation, isMatch, location.isBack, location.focusTargetSelector, location.skipFocus]);
  const mergedWrapperRef = (0, _compose.useMergeRefs)([forwardedRef, wrapperRef]);

  if (!isMatch) {
    return null;
  }

  if (prefersReducedMotion) {
    return (0, _element.createElement)(_view.View, (0, _extends2.default)({
      ref: mergedWrapperRef,
      className: classes
    }, otherProps), children);
  }

  const animate = {
    opacity: 1,
    transition: {
      delay: animationEnterDelay,
      duration: animationEnterDuration,
      ease: 'easeInOut'
    },
    x: 0
  }; // Disable the initial animation if the screen is the very first screen to be
  // rendered within the current `NavigatorProvider`.

  const initial = location.isInitial && !location.isBack ? false : {
    opacity: 0,
    x: (0, _i18n.isRTL)() && location.isBack || !(0, _i18n.isRTL)() && !location.isBack ? 50 : -50
  };
  const exit = {
    delay: animationExitDelay,
    opacity: 0,
    x: !(0, _i18n.isRTL)() && location.isBack || (0, _i18n.isRTL)() && !location.isBack ? 50 : -50,
    transition: {
      duration: animationExitDuration,
      ease: 'easeInOut'
    }
  };
  const animatedProps = {
    animate,
    exit,
    initial
  };
  return (0, _element.createElement)(_framerMotion.motion.div, (0, _extends2.default)({
    ref: mergedWrapperRef,
    className: classes
  }, otherProps, animatedProps), children);
}
/**
 * The `NavigatorScreen` component represents a single view/screen/panel and
 * should be used in combination with the `NavigatorProvider`, the
 * `NavigatorButton` and the `NavigatorBackButton` components (or the `useNavigator`
 * hook).
 *
 * @example
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */


const NavigatorScreen = (0, _context.contextConnect)(UnconnectedNavigatorScreen, 'NavigatorScreen');
exports.NavigatorScreen = NavigatorScreen;
var _default = NavigatorScreen;
exports.default = _default;
//# sourceMappingURL=component.js.map