"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useSlot;

var _valtio = require("valtio");

var _element = require("@wordpress/element");

var _slotFillContext = _interopRequireDefault(require("./slot-fill-context"));

// @ts-nocheck

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function useSlot(name) {
  const {
    updateSlot: registryUpdateSlot,
    unregisterSlot: registryUnregisterSlot,
    registerFill: registryRegisterFill,
    unregisterFill: registryUnregisterFill,
    ...registry
  } = (0, _element.useContext)(_slotFillContext.default);
  const slots = (0, _valtio.useSnapshot)(registry.slots, {
    sync: true
  }); // The important bit here is that this call ensures
  // the hook only causes a re-render if the slot
  // with the given name change, not any other slot.

  const slot = slots.get(name);
  const updateSlot = (0, _element.useCallback)(fillProps => {
    registryUpdateSlot(name, fillProps);
  }, [name, registryUpdateSlot]);
  const unregisterSlot = (0, _element.useCallback)(slotRef => {
    registryUnregisterSlot(name, slotRef);
  }, [name, registryUnregisterSlot]);
  const registerFill = (0, _element.useCallback)(fillRef => {
    registryRegisterFill(name, fillRef);
  }, [name, registryRegisterFill]);
  const unregisterFill = (0, _element.useCallback)(fillRef => {
    registryUnregisterFill(name, fillRef);
  }, [name, registryUnregisterFill]);
  return { ...slot,
    updateSlot,
    unregisterSlot,
    registerFill,
    unregisterFill
  };
}
//# sourceMappingURL=use-slot.js.map