{"version":3,"sources":["@wordpress/components/src/border-box-control/utils.ts"],"names":["sides","borderProps","isEmptyBorder","border","some","prop","undefined","isDefinedBorder","hasSplitBorders","allSidesEmpty","every","side","isCompleteBorder","Object","keys","indexOf","hasMixedBorders","borders","shorthandBorders","map","getShorthandBorderStyle","getSplitBorders","top","right","bottom","left","getBorderDiff","original","updated","diff","color","style","width","getCommonBorder","colors","styles","widths","forEach","push","allColorsMatch","value","allStylesMatch","allWidthsMatch","getMostCommonUnit","fallbackBorder","fallbackColor","fallbackStyle","fallbackWidth","hasVisibleBorder","borderStyle","filter","Boolean","join","values","units","filteredUnits","mode","length","maxCount","currentMode"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport type { CSSProperties } from 'react';\n\n/**\n * Internal dependencies\n */\nimport { parseCSSUnitValue } from '../utils/unit-values';\nimport type { Border } from '../border-control/types';\nimport type { AnyBorder, Borders, BorderProp, BorderSide } from './types';\n\nconst sides: BorderSide[] = [ 'top', 'right', 'bottom', 'left' ];\nconst borderProps: BorderProp[] = [ 'color', 'style', 'width' ];\n\nexport const isEmptyBorder = ( border?: Border ) => {\n\tif ( ! border ) {\n\t\treturn true;\n\t}\n\treturn ! borderProps.some( ( prop ) => border[ prop ] !== undefined );\n};\n\nexport const isDefinedBorder = ( border: AnyBorder ) => {\n\t// No border, no worries :)\n\tif ( ! border ) {\n\t\treturn false;\n\t}\n\n\t// If we have individual borders per side within the border object we\n\t// need to check whether any of those side borders have been set.\n\tif ( hasSplitBorders( border ) ) {\n\t\tconst allSidesEmpty = sides.every( ( side ) =>\n\t\t\tisEmptyBorder( ( border as Borders )[ side ] )\n\t\t);\n\n\t\treturn ! allSidesEmpty;\n\t}\n\n\t// If we have a top-level border only, check if that is empty. e.g.\n\t// { color: undefined, style: undefined, width: undefined }\n\t// Border radius can still be set within the border object as it is\n\t// handled separately.\n\treturn ! isEmptyBorder( border as Border );\n};\n\nexport const isCompleteBorder = ( border?: Border ) => {\n\tif ( ! border ) {\n\t\treturn false;\n\t}\n\n\treturn borderProps.every( ( prop ) => border[ prop ] !== undefined );\n};\n\nexport const hasSplitBorders = ( border: AnyBorder = {} ) => {\n\treturn Object.keys( border ).some(\n\t\t( side ) => sides.indexOf( side as BorderSide ) !== -1\n\t);\n};\n\nexport const hasMixedBorders = ( borders: AnyBorder ) => {\n\tif ( ! hasSplitBorders( borders ) ) {\n\t\treturn false;\n\t}\n\n\tconst shorthandBorders = sides.map( ( side: BorderSide ) =>\n\t\tgetShorthandBorderStyle( ( borders as Borders )?.[ side ] )\n\t);\n\n\treturn ! shorthandBorders.every(\n\t\t( border ) => border === shorthandBorders[ 0 ]\n\t);\n};\n\nexport const getSplitBorders = ( border?: Border ) => {\n\tif ( ! border || isEmptyBorder( border ) ) {\n\t\treturn undefined;\n\t}\n\n\treturn {\n\t\ttop: border,\n\t\tright: border,\n\t\tbottom: border,\n\t\tleft: border,\n\t};\n};\n\nexport const getBorderDiff = ( original: Border, updated: Border ) => {\n\tconst diff: Border = {};\n\n\tif ( original.color !== updated.color ) {\n\t\tdiff.color = updated.color;\n\t}\n\n\tif ( original.style !== updated.style ) {\n\t\tdiff.style = updated.style;\n\t}\n\n\tif ( original.width !== updated.width ) {\n\t\tdiff.width = updated.width;\n\t}\n\n\treturn diff;\n};\n\nexport const getCommonBorder = ( borders?: Borders ) => {\n\tif ( ! borders ) {\n\t\treturn undefined;\n\t}\n\n\tconst colors: ( CSSProperties[ 'borderColor' ] | undefined )[] = [];\n\tconst styles: ( CSSProperties[ 'borderStyle' ] | undefined )[] = [];\n\tconst widths: ( CSSProperties[ 'borderWidth' ] | undefined )[] = [];\n\n\tsides.forEach( ( side ) => {\n\t\tcolors.push( borders[ side ]?.color );\n\t\tstyles.push( borders[ side ]?.style );\n\t\twidths.push( borders[ side ]?.width );\n\t} );\n\n\tconst allColorsMatch = colors.every( ( value ) => value === colors[ 0 ] );\n\tconst allStylesMatch = styles.every( ( value ) => value === styles[ 0 ] );\n\tconst allWidthsMatch = widths.every( ( value ) => value === widths[ 0 ] );\n\n\treturn {\n\t\tcolor: allColorsMatch ? colors[ 0 ] : undefined,\n\t\tstyle: allStylesMatch ? styles[ 0 ] : undefined,\n\t\twidth: allWidthsMatch ? widths[ 0 ] : getMostCommonUnit( widths ),\n\t};\n};\n\nexport const getShorthandBorderStyle = (\n\tborder?: Border,\n\tfallbackBorder?: Border\n) => {\n\tif ( isEmptyBorder( border ) ) {\n\t\treturn fallbackBorder;\n\t}\n\n\tconst {\n\t\tcolor: fallbackColor,\n\t\tstyle: fallbackStyle,\n\t\twidth: fallbackWidth,\n\t} = fallbackBorder || {};\n\n\tconst {\n\t\tcolor = fallbackColor,\n\t\tstyle = fallbackStyle,\n\t\twidth = fallbackWidth,\n\t} = border as Border;\n\n\tconst hasVisibleBorder = ( !! width && width !== '0' ) || !! color;\n\tconst borderStyle = hasVisibleBorder ? style || 'solid' : style;\n\n\treturn [ width, borderStyle, color ].filter( Boolean ).join( ' ' );\n};\n\nexport const getMostCommonUnit = (\n\tvalues: Array< string | number | undefined >\n): string | undefined => {\n\t// Collect all the CSS units.\n\tconst units = values.map( ( value ) =>\n\t\tvalue === undefined ? undefined : parseCSSUnitValue( `${ value }` )[ 1 ]\n\t);\n\n\t// Return the most common unit out of only the defined CSS units.\n\tconst filteredUnits = units.filter( ( value ) => value !== undefined );\n\treturn mode( filteredUnits as string[] );\n};\n\n/**\n * Finds the mode value out of the array passed favouring the first value\n * as a tiebreaker.\n *\n * @param values Values to determine the mode from.\n *\n * @return The mode value.\n */\nfunction mode( values: Array< string > ): string | undefined {\n\tif ( values.length === 0 ) {\n\t\treturn undefined;\n\t}\n\n\tconst map: { [ index: string ]: number } = {};\n\tlet maxCount = 0;\n\tlet currentMode;\n\n\tvalues.forEach( ( value ) => {\n\t\tmap[ value ] = map[ value ] === undefined ? 1 : map[ value ] + 1;\n\n\t\tif ( map[ value ] > maxCount ) {\n\t\t\tcurrentMode = value;\n\t\t\tmaxCount = map[ value ];\n\t\t}\n\t} );\n\n\treturn currentMode;\n}\n"]}