{"version":3,"names":["createResolversCacheMiddleware","registry","storeName","next","action","resolvers","select","getCachedResolvers","resolverEntries","Object","entries","forEach","selectorName","resolversByArgs","resolver","stores","shouldInvalidate","value","args","undefined","status","dispatch","invalidateResolution"],"sources":["@wordpress/data/src/resolvers-cache-middleware.js"],"sourcesContent":["/** @typedef {import('./registry').WPDataRegistry} WPDataRegistry */\n\n/**\n * Creates a middleware handling resolvers cache invalidation.\n *\n * @param {WPDataRegistry} registry  Registry for which to create the middleware.\n * @param {string}         storeName Name of the store for which to create the middleware.\n *\n * @return {Function} Middleware function.\n */\nconst createResolversCacheMiddleware =\n\t( registry, storeName ) => () => ( next ) => ( action ) => {\n\t\tconst resolvers = registry.select( storeName ).getCachedResolvers();\n\t\tconst resolverEntries = Object.entries( resolvers );\n\t\tresolverEntries.forEach( ( [ selectorName, resolversByArgs ] ) => {\n\t\t\tconst resolver =\n\t\t\t\tregistry.stores[ storeName ]?.resolvers?.[ selectorName ];\n\t\t\tif ( ! resolver || ! resolver.shouldInvalidate ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresolversByArgs.forEach( ( value, args ) => {\n\t\t\t\t// Works around a bug in `EquivalentKeyMap` where `map.delete` merely sets an entry value\n\t\t\t\t// to `undefined` and `map.forEach` then iterates also over these orphaned entries.\n\t\t\t\tif ( value === undefined ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// resolversByArgs is the map Map([ args ] => boolean) storing the cache resolution status for a given selector.\n\t\t\t\t// If the value is \"finished\" or \"error\" it means this resolver has finished its resolution which means we need\n\t\t\t\t// to invalidate it, if it's true it means it's inflight and the invalidation is not necessary.\n\t\t\t\tif ( value.status !== 'finished' && value.status !== 'error' ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( ! resolver.shouldInvalidate( action, ...args ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Trigger cache invalidation\n\t\t\t\tregistry\n\t\t\t\t\t.dispatch( storeName )\n\t\t\t\t\t.invalidateResolution( selectorName, args );\n\t\t\t} );\n\t\t} );\n\t\treturn next( action );\n\t};\n\nexport default createResolversCacheMiddleware;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,8BAA8B,GACnCA,CAAEC,QAAQ,EAAEC,SAAS,KAAM,MAAQC,IAAI,IAAQC,MAAM,IAAM;EAC1D,MAAMC,SAAS,GAAGJ,QAAQ,CAACK,MAAM,CAAEJ,SAAU,CAAC,CAACK,kBAAkB,CAAC,CAAC;EACnE,MAAMC,eAAe,GAAGC,MAAM,CAACC,OAAO,CAAEL,SAAU,CAAC;EACnDG,eAAe,CAACG,OAAO,CAAE,CAAE,CAAEC,YAAY,EAAEC,eAAe,CAAE,KAAM;IACjE,MAAMC,QAAQ,GACbb,QAAQ,CAACc,MAAM,CAAEb,SAAS,CAAE,EAAEG,SAAS,GAAIO,YAAY,CAAE;IAC1D,IAAK,CAAEE,QAAQ,IAAI,CAAEA,QAAQ,CAACE,gBAAgB,EAAG;MAChD;IACD;IACAH,eAAe,CAACF,OAAO,CAAE,CAAEM,KAAK,EAAEC,IAAI,KAAM;MAC3C;MACA;MACA,IAAKD,KAAK,KAAKE,SAAS,EAAG;QAC1B;MACD;;MAEA;MACA;MACA;MACA,IAAKF,KAAK,CAACG,MAAM,KAAK,UAAU,IAAIH,KAAK,CAACG,MAAM,KAAK,OAAO,EAAG;QAC9D;MACD;MAEA,IAAK,CAAEN,QAAQ,CAACE,gBAAgB,CAAEZ,MAAM,EAAE,GAAGc,IAAK,CAAC,EAAG;QACrD;MACD;;MAEA;MACAjB,QAAQ,CACNoB,QAAQ,CAAEnB,SAAU,CAAC,CACrBoB,oBAAoB,CAAEV,YAAY,EAAEM,IAAK,CAAC;IAC7C,CAAE,CAAC;EACJ,CAAE,CAAC;EACH,OAAOf,IAAI,CAAEC,MAAO,CAAC;AACtB,CAAC;AAEF,eAAeJ,8BAA8B","ignoreList":[]}